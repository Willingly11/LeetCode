# 题解

这个解法的核心思想借鉴了 **莫里斯遍历 (Morris Traversal)**，它通过巧妙地修改树中节点的右指针，来避免使用栈或递归，从而实现常数级别的空间复杂度。

------



### 核心思想



算法的目标是模拟一个**前序遍历**（根 -> 左 -> 右），然后将遍历到的节点依次用右指针串联起来。

对于任何一个当前节点 `curr`：

1. **如果 `curr` 没有左子树**：说明它的下一个节点就是它的右子节点。我们不需要做任何操作，直接处理下一个节点，即 `curr = curr->right`。
2. **如果 `curr` 有左子树**：按照前序遍历，我们接下来应该处理整个左子树，处理完左子树的**最后一个**节点后，再回来处理 `curr` 的右子树。
   - 这个“左子树的最后一个节点”是谁呢？它就是 `curr` 的**前驱节点 (predecessor)**，也就是 `curr` 左子树中**最靠右**的那个节点。
   - 算法的关键就在于：找到这个前驱节点，然后将 `curr` 的**整个右子树**“嫁接”到这个前驱节点的右指针上。
   - 完成嫁接后，再将 `curr` 的**整个左子树**移动到 `curr` 的右边，并清空 `curr` 的左指针。

这样，我们就成功地将 `[左子树]` 插到了 `curr` 和 `[右子树]` 之间，并且形成了一个临时的链表结构，然后继续处理下一个节点。

------



### 图解步骤 (Step-by-Step)



我们用一个例子来分解这个过程。假设初始树是这样的：

```
    1
   / \
  2   5
 / \   \
3   4   6
```

**第1轮：`curr` 指向节点 1**

1. **检查左子树**：`curr` (节点1) 有左子树 (根为2)。

2. **寻找前驱节点**：从左子树的根 (节点2) 开始，一直向右走到底，找到节点 **4**。节点4就是节点1的前驱。

3. **嫁接右子树**：将 `curr` 的右子树 (节点5) 连接到前驱节点 (节点4) 的右指针上。`predecessor->right = curr->right;`  也就是 `4->right = 5`。

   - 树的结构变为：

   ```
       1
      / 
     2   
    / \   
   3   4
        \
         5
          \
           6 
   ```

4. **移动左子树**：将 `curr` 的左子树 (节点2) 变为它的右子树。`curr->right = curr->left;` 也就是 `1->right = 2`。

5. **清空左指针**：`curr->left = nullptr;`

   - 树的结构变为：

   ```
       1
        \
         2
        / \
       3   4
            \
             5
              \
               6
   ```

6. **前进**：`curr` 移动到它的新右子节点，`curr = curr->right;`，现在 `curr` 指向节点 **2**。

**第2轮：`curr` 指向节点 2**

1. **检查左子树**：`curr` (节点2) 有左子树 (根为3)。

2. **寻找前驱节点**：从左子树的根 (节点3) 开始，它没有右子节点，所以它自己就是前驱节点。

3. **嫁接右子树**：将 `curr` 的右子树 (节点4) 连接到前驱节点 (节点3) 的右指针上。`3->right = 4`。

4. **移动左子树**：将 `curr` 的左子树 (节点3) 变为它的右子树。`2->right = 3`。

5. **清空左指针**：`2->left = nullptr`。

   - 树的结构（也是最终的链表结构）变为：

   ```
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
   ```

6. **前进**：`curr` 移动到它的新右子节点，`curr = curr->right;`，现在 `curr` 指向节点 **3**。

**后续轮次**

- `curr` 指向节点 **3**：没有左子树，直接 `curr = curr->right`，`curr` 指向 **4**。
- `curr` 指向节点 **4**：没有左子树，直接 `curr = curr->right`，`curr` 指向 **5**。
- `curr` 指向节点 **5**：没有左子树，直接 `curr = curr->right`，`curr` 指向 **6**。
- `curr` 指向节点 **6**：没有左子树，直接 `curr = curr->right`，`curr` 变为 `nullptr`。

循环结束，整个树已经被原地展开成了链表。✨

------



### 代码解读



现在再来看代码就非常清晰了。

C++

```
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode *curr = root; // curr 是当前正在处理的节点
        while (curr != nullptr) {
            // 只有当左子树存在时，才需要进行处理
            if (curr->left != nullptr) {
                // next 指向左子树的根节点
                auto next = curr->left; 
                // predecessor 用来寻找 curr 的前驱节点
                auto predecessor = next; 
                // 循环找到左子树的最右节点，即前驱
                while (predecessor->right != nullptr) {
                    predecessor = predecessor->right;
                }

                // 步骤1：将 curr 的右子树嫁接到前驱节点的右指针上
                predecessor->right = curr->right;
                
                // 步骤2：清空 curr 的左指针
                curr->left = nullptr; 
                
                // 步骤3：将 curr 的原左子树移动到右指针上
                curr->right = next; 
            }
            // 移动到下一个节点，继续处理
            curr = curr->right;
        }
    }
};
```

这个算法的精妙之处在于，它利用了叶子节点（或子树中最后一个节点）的 `right` 空指针，来临时存储需要后续访问的节点信息（即 `curr->right`），从而避免了使用额外的栈，实现了 $O(1)$ 的空间复杂度。





# 莫里斯遍历 

我们来详细介绍一下**莫里斯遍历 (Morris Traversal)**。

莫里斯遍历是一种巧妙的二叉树遍历算法，它能在**不使用递归也**不使用**栈**的情况下，仅用 $O(1)$ 的额外空间复杂度，完成对二叉树的遍历。其核心思想是利用树中大量空闲的右指针，将它们临时用作“线索”或“回溯指针”，从而在遍历完左子树后能够顺利返回到根节点。

------



## 核心思想：建立和拆除“线索”



想象一下，当我们在二叉树中进行遍历时，最大的挑战是：**当我们从一个节点 `curr` 进入其左子树后，如何才能在左子树遍历结束后再回到 `curr`？**

- **递归/栈**：通过函数调用栈或显式的数据结构（如 `std::stack`）来保存路径，以便回溯。但这需要 $O(H)$ 的空间，其中 $H$ 是树的高度。
- **莫里斯遍历**：不使用额外空间，而是找到 `curr` 在中序遍历下的**前驱节点 (predecessor)**，并将该前驱节点的右指针（通常是 `nullptr`）临时指向 `curr`。这样，当左子树遍历到这个前驱节点时，就可以通过这个“线索”直接跳回到 `curr`。

这个过程可以分为两步：

1. **建立线索**：在进入左子树之前，找到前驱节点并将其右指针指向当前节点。
2. **拆除线索**：当通过线索回到当前节点后，意味着左子树已经遍历完毕，此时需要将前驱节点的右指针恢复为 `nullptr`，以保持树的原始结构。

------



## 算法步骤 (以中序遍历为例)



中序遍历的顺序是 **左 -> 根 -> 右**。莫里斯遍历通过以下步骤实现：

1. 初始化一个指针 `curr` 指向 `root`。
2. 当 `curr` 不为 `nullptr` 时，进行循环：
   - **情况一：`curr` 没有左子树 (`curr->left == nullptr`)**
     - 这意味着当前节点 `curr` 没有需要优先处理的左边部分。
     - 因此，直接“访问” `curr` 节点（例如，打印它的值）。
     - 然后移动到右子树，即 `curr = curr->right`。
   - **情况二：`curr` 有左子树 (`curr->left != nullptr`)**
     - 需要先遍历完整个左子树，再回来访问 `curr`。为了能回来，我们需要找到 `curr` 的前驱节点。
     - **寻找前驱节点 `predecessor`**：从 `curr->left` 开始，一直向右走到底 (`predecessor = predecessor->right`)，直到找到左子树的最右侧节点。这个节点就是 `curr` 的中序前驱。
     - **根据前驱节点的右指针进行判断**：
       - **a) 如果 `predecessor->right == nullptr`**：说明这是第一次访问到 `curr`，线索尚未建立。
         - **建立线索**：让 `predecessor->right = curr`。
         - 然后，**进入左子树**进行遍历，即 `curr = curr->left`。
       - **b) 如果 `predecessor->right == curr`**：说明线索已经存在，代表我们是通过这个线索从左子树**返回**到 `curr` 的。
         - 这意味着 `curr` 的整个左子树已经遍历完毕。
         - **拆除线索**：将前驱节点的右指针恢复原状，`predecessor->right = nullptr`。
         - **访问 `curr` 节点**。
         - 最后，**进入右子树**进行遍历，即 `curr = curr->right`。
3. 当 `curr` 为 `nullptr` 时，遍历结束。



## code实现

### 前序遍历

```
class Solution {
public:
    std::vector<int> preorderTraversal(TreeNode* root) {
        std::vector<int> result;
        TreeNode* curr = root;
        TreeNode* predecessor = nullptr;

        while (curr != nullptr) {
            if (curr->left == nullptr) {
                // 情况1: 没有左子树
                // 访问当前节点，然后转向右子树
                result.push_back(curr->val);
                curr = curr->right;
            } else {
                // 情况2: 有左子树
                // 找到前驱节点
                predecessor = curr->left;
                while (predecessor->right != nullptr && predecessor->right != curr) {
                    predecessor = predecessor->right;
                }

                if (predecessor->right == nullptr) {
                    // 2.a: 第一次到达，建立线索
                    // 立即访问当前节点（这是前序遍历的核心）
                    result.push_back(curr->val); 
                    predecessor->right = curr; // 建立线索
                    curr = curr->left;         // 转向左子树
                } else {
                    // 2.b: 通过线索返回，说明左子树已遍历完
                    // 拆除线索即可，不需要再访问
                    predecessor->right = nullptr;
                    curr = curr->right;        // 转向右子树
                }
            }
        }
        return result;
    }
};
```



### 中序遍历

```
class Solution {
public:
    std::vector<int> inorderTraversal(TreeNode* root) {
        std::vector<int> result;
        TreeNode* curr = root;
        TreeNode* predecessor = nullptr;

        while (curr != nullptr) {
            if (curr->left == nullptr) {
                // 情况1: 当前节点没有左子树
                // 访问当前节点，然后转向右子树
                result.push_back(curr->val);
                curr = curr->right;
            } else {
                // 情况2: 当前节点有左子树
                // 找到当前节点的前驱节点
                predecessor = curr->left;
                while (predecessor->right != nullptr && predecessor->right != curr) {
                    predecessor = predecessor->right;
                }

                if (predecessor->right == nullptr) {
                    // 2.a: 第一次到达该节点，建立线索
                    // 将前驱节点的右指针指向当前节点
                    predecessor->right = curr;
                    // 继续遍历左子树
                    curr = curr->left;
                } else {
                    // 2.b: 通过线索返回到当前节点，说明左子树已遍历完
                    // 拆除线索
                    predecessor->right = nullptr;
                    // 访问当前节点（这是中序遍历的核心）
                    result.push_back(curr->val);
                    // 左子树和根节点都已处理，转向右子树
                    curr = curr->right;
                }
            }
        }
        return result;
    }
};
```



### 后序遍历

使用莫里斯遍历实现NRL遍历，然后反转遍历结果，就得到了LRN后续遍历的结果

```
#include <iostream>
#include <vector>
#include <algorithm>

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    std::vector<int> postorderTraversal(TreeNode* root) {
        std::vector<int> result;
        if (root == nullptr) {
            return result;
        }

        TreeNode* curr = root;
        TreeNode* successor = nullptr; // 在这里我们找的是后继节点

        // 步骤1：执行 “根 -> 右 -> 左” 的莫里斯遍历
        while (curr != nullptr) {
            if (curr->right == nullptr) {
                // 没有右子树，访问并转向左边
                result.push_back(curr->val);
                curr = curr->left;
            } else {
                // 找到右子树中的“中序后继”（即右子树的最左节点）
                successor = curr->right;
                while (successor->left != nullptr && successor->left != curr) {
                    successor = successor->left;
                }

                if (successor->left == nullptr) {
                    // 第一次访问，建立线索
                    result.push_back(curr->val); // 访问根节点
                    successor->left = curr;      // 建立线索
                    curr = curr->right;          // 探索右子树
                } else {
                    // 通过线索返回，说明右子树已处理完
                    successor->left = nullptr; // 拆除线索
                    curr = curr->left;         // 探索左子树
                }
            }
        }

        // 步骤2：将最终结果反转
        std::reverse(result.begin(), result.end());

        return result;
    }
};
```

