# 平衡二叉树

构建平衡二叉树主要分为两大类场景：

1. **动态构建**：在一个空的或已有的树中，**逐个插入或删除**节点，并在这个过程中始终**维持树的平衡**。这是最常见的场景，典型代表是 **AVL树** 和 **红黑树**。
2. **静态构建**：给定**所有**的元素（通常是一个有序序列），一次性地构建出一棵平衡二叉树。

下面我们将详细讲解这两种场景下的构建方法。

------



### 1. 动态构建：通过“旋转”操作维持平衡

当我们在一个二叉搜索树（BST）中插入或删除节点时，树的平衡可能会被打破。为了恢复平衡，我们需要一种机制来调整树的结构，这种机制就是**旋转 (Rotation)**。



#### 什么是平衡？

最经典的定义来自于 **AVL树**：对于树中的**任意一个节点**，其**左子树的高度**与**右子树的高度**之差的绝对值不能超过 1。这个差值被称为**平衡因子 (Balance Factor)**。



#### 核心操作：旋转

旋转是修改树结构、降低树高度同时保持二叉搜索树性质的局部操作。主要有两种基本旋转：

- **右旋转 (Right Rotation)**：当一个节点的左子树太高时使用。
- **左旋转 (Left Rotation)**：当一个节点的右子树太高时使用。

**图解右旋转（以节点 `z` 为轴心）：**

```
      z (不平衡)             y
     / \                   /   \
    y   T4      --->      x     z
   / \                   / \   / \
  x   T3                T1 T2 T3 T4
 / \
T1 T2
```

这个操作让 `y` 成为新的根，`z` 成为 `y` 的右孩子，同时巧妙地将 `y` 原来的右子树 `T3` 挂接为 `z` 的新左子树，整个过程保持了中序遍历 `(T1, x, T2, y, T3, z, T4)` 不变。左旋转与此过程完全对称。



#### 构建算法示例：AVL树的插入

AVL树是第一种被发明的自平衡二叉搜索树，它的平衡条件非常严格，因此理解它的插入过程是理解动态构建的关键。

**插入一个新节点的步骤：**

1. **标准BST插入**：首先，按照普通二叉搜索树的规则，找到合适的位置插入新节点。
2. **回溯更新与检查**：从插入节点开始，**向上回溯**到根节点，沿途更新每个祖先节点的高度，并检查它们的**平衡因子**。
3. **发现不平衡并执行旋转**：一旦发现第一个平衡因子变为 `+2` 或 `-2` 的节点（称之为 `z`），就需要根据 `z` 的孙子节点的插入位置，执行相应的旋转来恢复平衡。总共有四种情况：
   - **LL (左-左)**：新节点插入在 `z` 的**左孩子 (`y`)** 的**左子树 (`x`)**。
     - **解决方法**：对 `z` 执行一次**右旋转**。
   - **RR (右-右)**：新节点插入在 `z` 的**右孩子 (`y`)** 的**右子树 (`x`)**。
     - **解决方法**：对 `z` 执行一次**左旋转**。
   - **LR (左-右)**：新节点插入在 `z` 的**左孩子 (`y`)** 的**右子树 (`x`)**。
     - **解决方法**：先对 `y` **左旋转**，使其变为 LL 型，然后再对 `z` **右旋转**。
   - **RL (右-左)**：新节点插入在 `z` 的**右孩子 (`y`)** 的**左子树 (`x`)**。
     - **解决方法**：先对 `y` **右旋转**，使其变为 RR 型，然后再对 `z` **左旋转**。

完成一次旋转后，以 `z` 为根的这棵子树就恢复了平衡，并且其高度与插入前相同，因此**无需再向上回溯**，整个插入操作完成。

**红黑树 (Red-Black Tree)** 是另一种著名的自平衡二叉搜索树（也是 `std::map` 和 `std::set` 的常用实现），它通过一套节点颜色（红/黑）和更复杂的规则来维持一种“大致的平衡”，其平衡性没有 AVL 树那么严格，但通常插入和删除所需的旋转次数更少，综合性能更好。

------



### 2. 静态构建：从有序数组构建

这是您在上一个问题中提到的场景，它不是动态地维护平衡，而是一次性地完成构建。

**核心思想：分治法 (Divide and Conquer)**

为了构建一棵平衡树，我们应该让根节点两边的子树节点数量尽可能相等。对于一个**有序数组**，实现这一点的最佳方法就是**选择数组的中间元素作为根节点**。

**算法步骤：**

1. **确定根节点**：选择有序数组的中间元素 `nums[mid]` 作为当前树（或子树）的根节点。
2. **划分左右子树**：
   - 数组中 `mid` 左边的部分 `[left, mid-1]` 的所有元素都比 `nums[mid]` 小，它们将构成**左子树**。
   - 数组中 `mid` 右边的部分 `[mid+1, right]` 的所有元素都比 `nums[mid]` 大，它们将构成**右子树**。
3. **递归构建**：
   - 对左边的子数组递归调用此过程，构建出完整的左子树，并将其连接到根节点的左孩子。
   - 对右边的子数组递归调用此过程，构建出完整的右子树，并将其连接到根节点的右孩子。
4. **终止条件**：当子数组为空时（即 `left > right`），返回 `nullptr`。

这个递归过程天然地保证了每个节点的左右子树高度差最多为1，从而构建出一棵高度平衡的二叉搜索树。

------



### 总结对比

| **方法**                  | **动态构建 (以AVL树为例)**                                   | **静态构建 (从有序数组)**                                    |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **使用场景**              | 数据流是动态的，需要频繁地插入和删除节点，并随时保持树的平衡。 | 已知所有数据，需要一次性构建出最佳的平衡树结构。             |
| **核心思想**              | **失衡-修复**：先按BST规则操作，然后回溯检查，通过**旋转**来局部修复被破坏的平衡。 | **分治**：通过递归地选择中点作为根，从一开始就保证了全局的平衡。 |
| **时间复杂度 (单个操作)** | 插入/删除/查找均为 **O(log N)**                              | 构建整棵树为 **O(N)**                                        |
| **实现复杂度**            | 较高，需要处理四种旋转情况。                                 | 较低，是经典的分治递归模式。                                 |



# 动态构建平衡二叉树

“动态构建”指的是在一个空的或已有的树结构中，通过**逐个插入或删除节点**的操作，并在每一步操作后，都能**自动维持或恢复树的平衡状态**。这与从一个有序数组一次性构建是完全不同的场景。

实现这一目标的数据结构被称为**自平衡二叉搜索树 (Self-Balancing Binary Search Tree)**。其中，最经典、最适合用来学习原理的就是 **AVL 树**。

## 1. 动态构建的算法：插入一个新节点

下面是向 AVL 树中插入一个新节点的完整动态构建步骤：

#### **第 1 步：执行标准的 BST 插入**

首先，忽略平衡问题，按照普通二叉搜索树的规则，找到新节点应该插入的位置并将其插入。

#### **第 2 步：回溯并更新高度**

从新插入的节点开始，**沿着其祖先路径向上回溯**至根节点。在回溯的每一步，都需要**更新当前节点的高度**。一个节点的高度等于其左右子树中较高者的高度再加 1。

#### **第 3 步：检查平衡因子并执行旋转**

在更新完每个节点的高度后，立即计算该节点的**平衡因子**。

一旦发现第一个平衡因子变为 `+2` 或 `-2` 的节点（我们称之为 `z`），就说明树从 `z` 节点开始失衡了。此时，需要根据导致失衡的路径（即新节点插入的位置），执行四种旋转操作中的一种来恢复平衡。

这四种情况分别是 **LL、RR、LR、RL**，判断的依据是新节点相对于 `z` 的路径。

- **LL (左-左)**: 新节点插入在 `z` 的**左孩子 (`y`)** 的**左子树**。
  - **解决方法**: 对 `z` 执行一次**右旋转**。
- **RR (右-右)**: 新节点插入在 `z` 的**右孩子 (`y`)** 的**右子树**。
  - **解决方法**: 对 `z` 执行一次**左旋转**。
- **LR (左-右)**: 新节点插入在 `z` 的**左孩子 (`y`)** 的**右子树**。
  - **解决方法**: 先对 `y` **左旋转**，将其变为 LL 型，然后再对 `z` **右旋转**。
- **RL (右--左)**: 新节点插入在 `z` 的**右孩子 (`y`)** 的**左子树**。
  - **解决方法**: 先对 `y` **右旋转**，使其变为 RR 型，然后再对 `z` **左旋转**。

**关键特性**：对于 AVL 树的插入操作，一旦完成了一次旋转修复，**整棵树就恢复了平衡**，不需要再继续向上回溯检查。



## Code

```c++
// 节点结构，增加了 height 成员
struct Node {
    int key;
    Node *left;
    Node *right;
    int height;
};

// 辅助函数：获取节点高度（处理空指针情况）
int getHeight(Node* node) {
    if (node == nullptr) return 0;
    return node->height;
}

// 辅助函数：创建新节点
Node* newNode(int key) {
    Node* node = new Node();
    node->key = key;
    node->left = nullptr;
    node->right = nullptr;
    node->height = 1; // 新插入的叶子节点高度为 1
    return node;
}

/**
 * @brief 对不平衡节点 z 执行右旋转 (用于 LL 型失衡)
 * * z                   y
 * / \                 /   \
 * y   T4    --->      x     z
 * / \                 / \   / \
 * x   T3              T1 T2 T3 T4
 *
 * @param z 不平衡的节点
 * @return 旋转后该子树的新根节点 (y)
 */

Node* rightRotate(Node* z) {
    // 按照 z-y-x 模型命名
    Node* y = z->left;
    Node* T3 = y->right;

    // 执行旋转
    y->right = z;
    z->left = T3;

    // 重要：先更新下降了的节点 z 的高度，再更新上升了的节点 y 的高度
    z->height = 1 + std::max(getHeight(z->left), getHeight(z->right));
    y->height = 1 + std::max(getHeight(y->left), getHeight(y->right));

    // 返回新的根节点
    return y;
}

/**
 * @brief 对不平衡节点 z 执行左旋转 (用于 RR 型失衡)
 *
 * z                        y
 * / \                     /   \
 * T1  y          --->     z     x
 * 	  / \                 / \   / \
 *   T2  x               T1 T2 T3 T4
 *      / \
 *     T3 T4
 *
 * @param z 不平衡的节点
 * @return 旋转后该子树的新根节点 (y)
 */
Node* leftRotate(Node* z) {
    // 按照 z-y-x 模型命名
    Node* y = z->right;
    Node* T2 = y->left;

    // 执行旋转
    y->left = z;
    z->right = T2;

    // 更新高度
    z->height = 1 + std::max(getHeight(z->left), getHeight(z->right));
    y->height = 1 + std::max(getHeight(y->left), getHeight(y->right));

    // 返回新的根节点
    return y;
}

// 辅助函数：获取节点的平衡因子
int getBalance(Node* node) {
    if (node == nullptr) return 0;
    // 平衡因子 = 左子树高度 - 右子树高度
    return getHeight(node->left) - getHeight(node->right);
}

// 递归地插入新节点，并动态维持平衡
Node* insert(Node* node, int key) {
    // 1. 执行标准的 BST 插入
    if (node == nullptr)
        return(newNode(key));

    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);
    else // 不允许插入重复键
        return node;

    // 2. 更新当前祖先节点的高度
    node->height = 1 + std::max(getHeight(node->left), getHeight(node->right));

    // 3. 获取平衡因子，检查是否失衡
    int balance = getBalance(node);

    // 4. 如果失衡，根据四种情况执行相应的旋转
    //    此时，`node` 就是我们模型中的不平衡节点 `z`

    // --- 左子树过高 (Left Heavy) ---
    // LL Case: 新节点插入在 z 的左孩子(y)的左子树(x)
    if (balance > 1 && key < node->left->key) {
        return rightRotate(node); // 对 z 进行一次右旋
    }

    // LR Case: 新节点插入在 z 的左孩子(y)的右子树(x)
    if (balance > 1 && key > node->left->key) {
        // 先对 y (node->left) 进行左旋，变为 LL 型
        node->left = leftRotate(node->left);
        // 再对 z (node) 进行右旋
        return rightRotate(node);
    }

    // --- 右子树过高 (Right Heavy) ---
    // RR Case: 新节点插入在 z 的右孩子(y)的右子树(x)
    if (balance < -1 && key > node->right->key) {
        return leftRotate(node); // 对 z 进行一次左旋
    }

    // RL Case: 新节点插入在 z 的右孩子(y)的左子树(x)
    if (balance < -1 && key < node->right->key) {
        // 先对 y (node->right) 进行右旋，变为 RR 型
        node->right = rightRotate(node->right);
        // 再对 z (node) 进行左旋
        return leftRotate(node);
    }

    // 如果未失衡，返回原节点指针
    return node;
}

// 辅助函数：前序遍历打印树（用于验证）
void preOrder(Node *root) {
    if(root != nullptr) {
        std::cout << root->key << " ";
        preOrder(root->left);
        preOrder(root->right);
    }
}
```

